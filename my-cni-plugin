#!/bin/bash

# TODO:
# Tasks of the CNI plugin:
# 0. Create bridge in default netns
# 1. Create network interface in Pod namespace and assign it an IP address => DONE
# 2. Ensure the following types of connectivity (all types include vice versa direction)
#    1. Pod <=> agent on node                 : Pod => node (bridge is default gateway for Pods), node => Pod (default route created in default namespace)
#    2. Pod ot other Pod on same node         : Needs FORWARD ACCEPT rules in iptables of default netns (packets: Pod netns => bridge in default netns => Pod netns)
#    3. Pod to other Pod on different node    : Needs route in default netns (from bridge to other node)
#    4. Pod to destinations outside cluster   : Needs NAT in the default netns (IP Masquerade)
# 
# It seems that the bridge plugin (which this plugin tries to imitate) also specifically includes items 0, 2.2, and 2.4 (1 and 2.1 are obvious, not sure about 2.3).
# This means, the bridge plugin also creates the bridge if it doesn't exist and sets up NAT and iptable rules.
# => Add this to this CNI plugin: a section that checks if a given setting already exists and implements it, if it doesn't.
#
# NAT vs IP Masquerade: 
#   IP Masquerade is one type (and the most common type) of NAT. So much that when we speak of NAT, we actually mean IP Masquerade.
#   https://www.dslreports.com/forum/r31309035-IP-Masquerade-vs-NAT


# Read NetConf
netconf=$(cat /dev/stdin)
# Example NetConf:
# {
#   "cniVersion": "0.3.1",
#   "name": "my-pod-network",
#   "type": "my-cni-plugin",
#   "myPodCidrRange": "20.0.0.0/24",
#   "myBridgeIp": "20.0.0.1",
#   "myBridgeName": "cni0"
# }

# Log the entire input for this plugin invocation
cat <<EOF
CNI_COMMAND=$CNI_COMMAND
CNI_CONTAINERID=$CNI_CONTAINERID
CNI_NETNS=$CNI_NETNS
CNI_IFNAME=$CNI_IFNAME
CNI_PATH=$CNI_PATH
$netconf
EOF

# Extract values from NetConf
pod_cidr_range=$(jq -r ".myPodCidrRange" <<<"$netconf")
bridge_ip=$(jq -r ".myBridgeIp" <<<"$netconf")
bridge_name=$(jq -r ".myBridgeName" <<<"$netconf")

# Add 'ipam' field to a copy of NetConf for the host-local IPAM plugin
ipam_netconf=$(jq ". += {
  ipam: {
    subnet: \"$pod_cidr_range\",
    gateway: \"$bridge_ip\"
  }
}" <<<"$netconf")

case "$CNI_COMMAND" in

  # Invoked by kubelet during Pod creation (after creating a netns for the Pod)
  ADD)
    # Make the Pod netns discoverable by 'ip' as $CNI_CONTAINERID
    mkdir -p /var/run/netns/ && ln -s "$CNI_NETNS" /var/run/netns/"$CNI_CONTAINERID"

    # Name of host-end of the veth pair (name of the Pod-end is $CNI_IFNAME)
    host_ifname=veth$RANDOM

    # Default netns: create new veth pair
    ip link add "$CNI_IFNAME" type veth peer name "$host_ifname"

    # Default netns: enable host-end of the pair and add it to the bridge
    ip link set "$host_ifname" up master "$bridge_name"

    # Default netns: enable Pod-end of the pair and put it into the Pod netns
    ip link set "$CNI_IFNAME" up netns "$CNI_CONTAINERID"
    
    # Pod netns: add a default route to the bridge via the Pod-end of the pair
    ip netns exec "$CNI_CONTAINERID" ip route add default via "$bridge_ip" dev "$CNI_IFNAME"

    # Invoke host-local IPAM plugin to select an IP address for the Pod
    ipam_response=$(/opt/cni/bin/host-local <<<"$ipam_netconf")
    # Example host-local response:
    # {
    #   "cniVersion": "0.3.1",
    #   "ips": [
    #     {
    #       "version": "4",
    #       "address": "20.0.0.4/24",
    #       "gateway": "20.0.0.1"
    #     }
    #   ],
    #   "dns": {}
    # }

    # Extract the IP address that the IPAM plugin selected for the Pod
    pod_ip=$(jq -r '.ips[0].address' <<<"$ipam_response")

    # Pod netns: assign the selected IP address to the Pod-end of the pair
    ip netns exec "$CNI_CONTAINERID" ip addr add "$pod_ip" "$CNI_IFNAME"

    # Write response by adding 'interfaces' field to IPAM plugin response
    jq ". += {
          interfaces: [
            {
              name: \"$CNI_IFNAME\",
              sandbox: \"$CNI_NETNS\"
            }
          ]
        } |
        .ips[0] += {
          interface: 0
        }" <<<"$ipam_response"
    ;;

  # Invoked by kubelet during Pod deletion (before deleting the Pod's netns).
  # Note: since the kubelet will delete the entire network namespace, it is not
  # necessary to delete the network resources that were created by ADD because
  # they will be automatically deleted when the network namespace is deleted.
  DEL)
    # Invoke host-local IPAM plugin to un-reserve the Pod's IP address
    /opt/cni/bin/host-local <<<"$ipam_netconf"
    ;;

  # Return implemented and supported versions of CNI specification
  VERSION)
    echo '{"cniVersion":"0.3.1","supportedVersions":["0.1.0","0.2.0","0.3.0","0.3.1"]}'
    ;;
esac
