#!/bin/bash

# Parameters
bridge_name=cni0
setup_done=/var/lib/cni/my-cni-plugin-setup-done
logs=/var/log/cni/my-cni-plugin.log
mkdir -p "$(dirname "$logs")" "$(dirname "$setup_done")"

# Direct fd3 to stdout and fd1 and fd2 to a file, so commands write to the file
# by default, and stdout receives only what's explicitly written to fd3.
exec 3>&1
exec &>>"$logs"

# Read NetConf
netconf=$(cat /dev/stdin)
# Example NetConf:
# {
#   "cniVersion": "0.3.1",
#   "name": "my-pod-network",
#   "type": "my-cni-plugin",
#   "myHostNetwork": "10.0.0.0/16",
#   "myPodNetwork": "200.200.0.0/16",
#   "myPodSubnet": "200.200.1.0/24"
# }

log() {
  echo -e "\e[32$(date): $*\e[0m"
}

# Log the entire input for this plugin invocation
log "$(cat <<EOF
CNI_COMMAND=$CNI_COMMAND
CNI_CONTAINERID=$CNI_CONTAINERID
CNI_NETNS=$CNI_NETNS
CNI_IFNAME=$CNI_IFNAME
CNI_PATH=$CNI_PATH
NetConf: $netconf
EOF
)"

# Extract values from NetConf
host_network=$(jq -r ".myHostNetwork" <<<"$netconf")
pod_network=$(jq -r ".myPodNetwork" <<<"$netconf")
pod_subnet=$(jq -r ".myPodSubnet" <<<"$netconf")

# Add 'ipam' field to a copy of NetConf for the host-local IPAM plugin
ipam_netconf=$(jq ". += {ipam: {subnet: \"$pod_subnet\"}}" <<<"$netconf")

case "$CNI_COMMAND" in

  # Invoked by kubelet during Pod creation (after creating a netns for the Pod)
  ADD)

    # Invoke host-local IPAM plugin
    ipam_response=$(/opt/cni/bin/host-local <<<"$ipam_netconf")
    # Example host-local response:
    # {
    #   "cniVersion": "0.3.1",
    #   "ips": [
    #     {
    #       "version": "4",
    #       "address": "20.0.0.4/24",
    #       "gateway": "20.0.0.1"
    #     }
    #   ],
    #   "dns": {}
    # }

    # Extract Pod and gateway (bridge) IP address selected by IPAM plugin
    pod_ip=$(jq -r '.ips[0].address' <<<"$ipam_response")
    bridge_ip=$(jq -r '.ips[0].gateway' <<<"$ipam_response")

    # Do one-time setup if it hasn't yet been done
    if mkdir "$setup_done" &>/dev/null; then

      # Delete bridge if it already exists (if reinstalling the plugin)
      ip link show "$bridge_name" &>/dev/null && ip link delete "$bridge_name"

      # Create and enable bridge and assigne IP address to it
      ip link add "$bridge_name" type bridge
      ip link set "$bridge_name" up
      ip address add "$bridge_ip"/"${pod_subnet#*/}" dev "$bridge_name"

      # Allow packets to/from Pods to pass through default network namespace
      iptables -A FORWARD -s "$pod_network" -j ACCEPT
      iptables -A FORWARD -d "$pod_network" -j ACCEPT

      # Enable NAT *only* for traffic going out of the cluster
      iptables -t nat -N MY_CNI_MASQUERADE
      iptables -t nat -A MY_CNI_MASQUERADE -d "$pod_network" -j RETURN
      iptables -t nat -A MY_CNI_MASQUERADE -d "$host_network" -j RETURN
      iptables -t nat -A MY_CNI_MASQUERADE -j MASQUERADE
      iptables -t nat -A POSTROUTING -s "$pod_subnet" -j MY_CNI_MASQUERADE

      # If this plugin was used in a traditional physical network, then you
      # would need to set up the inter-node Pod network routes here.
    fi

    # Make the Pod netns discoverable by 'ip' as $CNI_CONTAINERID
    mkdir -p /var/run/netns/ && ln -sf "$CNI_NETNS" /var/run/netns/"$CNI_CONTAINERID"

    # Name of host-end of the veth pair (name of the Pod-end is $CNI_IFNAME)
    host_ifname=veth$RANDOM

    # Create new veth pair
    ip link add "$CNI_IFNAME" type veth peer name "$host_ifname"

    # Enable host-end of the pair and add it to the bridge
    ip link set "$host_ifname" up master "$bridge_name"

    # Enable Pod-end of the pair and put it into the Pod netns
    ip link set "$CNI_IFNAME" up netns "$CNI_CONTAINERID"

    # Assign the selected IP address to the Pod-end of the pair
    ip netns exec "$CNI_CONTAINERID" ip address add "$pod_ip" dev "$CNI_IFNAME"
    
    # Add a default route to the bridge via the Pod-end of the pair
    ip netns exec "$CNI_CONTAINERID" ip route add default via "$bridge_ip" dev "$CNI_IFNAME"

    # Write response by adding 'interfaces' field to IPAM plugin response
    response=$(jq ". += {
          interfaces: [
            {
              name: \"$CNI_IFNAME\",
              sandbox: \"$CNI_NETNS\"
            }
          ]
        } |
        .ips[0] += {
          interface: 0
        }" <<<"$ipam_response")
    log "ADD response: $response"
    echo "$response" >&3
    ;;

  # Invoked by kubelet during Pod deletion (before deleting the Pod's netns).
  # Note: since the kubelet will delete the entire network namespace, it is not
  # necessary to delete the network resources that were created by ADD because
  # they will be automatically deleted when the network namespace is deleted.
  DEL)
    # Relase the Pod's IP address from the host-local IPAM plugin
    /opt/cni/bin/host-local <<<"$ipam_netconf"

    # Delete link to namespace file (which enables the namespace itself to be deleted)
    rm -f /var/run/netns/"$CNI_CONTAINERID"
    ;;

  # Return implemented and supported versions of CNI specification
  VERSION)
    echo '{"cniVersion":"0.3.1","supportedVersions":["0.1.0","0.2.0","0.3.0","0.3.1"]}' >&3
    ;;
esac
